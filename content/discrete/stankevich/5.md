---
title: "Сумматор, двоичный каскадный сумматор, умножитель, дерево Уоллеса"
index: 5
lectureYouTubeLink:
  - "https://www.youtube.com/watch?v=82P3OkxbH7w"
author:
  name: "Худалла А.Б."
  isu: 501855
---

mjx-hidden
$\newcommand{\ihat}{\hat \imath}$
$\newcommand{\jhat}{\hat \jmath}$
$\newcommand{\pipe}{\,|\,}$
$\newcommand{\lra}{\Leftrightarrow}$
$\newcommand{\la}{\Leftarrow}$
$\newcommand{\ra}{\Rightarrow}$
$\newcommand{\mb}{\mathbb}$
$\newcommand{\br}[1]{\{{#1}\}}$
$\newcommand{\ang}[1]{\langle{#1}\rangle}$
$\newcommand{\ov}{\overline}$
$\newcommand{\argsum}[2]{\underset{#2}{\overset {#1}\sum}}$
$\newcommand{\arghuge}[1]{\huge{#1}\;\normalsize}$
$\newcommand{\tmatrix}[1]{\begin{pmatrix}#1\end{pmatrix}}$
$\newcommand{\bmatrix}[1]{\begin{Bmatrix}#1\end{Bmatrix}}$
$\newcommand{\matal}[1]{\begin{align}#1\end{align}}$
$\newcommand{\pmatrix}[1]{\begin{vmatrix}#1\end{vmatrix}}$
\$\newcommand\{\system\}\[1\]\{\large\left \\{ \begin\{align\}#1\end\{align\} \right \.\normalsize\}\$
\$\newcommand\{\mc\}\{\mathcal\}\$

---


## Обзорно по побитовым операциям:

![image](/_media/Pasted%20image%2020251013205728.png)
>Побитовое "и" - схема из функциональных элементов

С остальными операциями также

---

## Сумматоры

![image](/_media/Pasted%20image%2020251013212351.png)
![image](/_media/Pasted%20image%2020251013212556.png)


![image](/_media/Pasted%20image%2020251013212836.png)
>Адекватный сумматор трёхбитного числа (поразрядный)
>$size = n$
>$depth = n$
>Где $n$ это количество бит

Сумматор построенный на рисунке выше называется каскадным от слова "[cascade](https://dictionary.cambridge.org/dictionary/english/cascade)".

Неприятно что $depth = n$, хочется сделать за $log\;n$ так что <img src="/_media/Pasted%20image%2020251013213517.png" width="48">

---

Абстрагируемся от сложной задачи и подумаем, о том, когда бит переноса точно $\huge \mb 1$, а когда точно $\huge \mb 0$.
Намеренно не включим бит переноса с предыдущего разряда, чтобы уследить зависимость от него:

| a   | b   | c (бит переноса)      | d   |
| --- | --- | --------------------- | --- |
| 0   | 0   | 0                     | 0   |
| 0   | 1   | зависит от пред. б.п. | 1   |
| 1   | 0   | зависит от пред. б.п. | 1   |
| 1   | 1   | 1                     | 0   |

Получается, наш сумматор с точки зрения функции относительно предыдущего бита переноса, принимает всего 3 значения (этим значениям даже придуманы названия):
- $k$ - kill - сумма двух нулей и у нас 100% не будет бита переноса дальше, даже если он пришёл с предыдущего разряда
- $p$ - propagate - сумма разных значений; если нам пришёл бит переноса с предыдущего разряда, он же пойдёт в бит переноса у нас: если не пришёл, будет 0
- $g$ - generate - сумма двух единиц и у нас 100% будет бит переноса, даже если нам он не пришёл с предыдущего разряда

Представим что мы делаем композицию двух функций описанных выше, то-есть смотрим на входы двух сумматоров и пытаемся понять, если сумматор "пропустит через себя" бит переноса (we try to determine if the device will propagate the carry bit), или выдаст предетерменированный результат ($\large \mb 0 / \mb 1$).

Рассмотрим таблицу композиции функции (1 - первая операция, 2 - вторая):

| ${}_1{\backslash}^2$ | $k$ | $g$ | $p$ |
| -------------------- | --- | --- | --- |
| $k$                  | $k$ | $g$ | $k$ |
| $g$                  | $k$ | $g$ | $g$ |
| $p$                  | $k$ | $g$ | $p$ |

$p$ - нейтральный элемент, коммутативности нет, ассоциативность есть (*так сказал А.С. Станкевич, я ему верю*)

Эту функцию композиции отобразим схематично, для тех кто ещё не врубился что тут происходит: <img src="/_media/CleanShot%202025-10-13%20at%2022.12.10@2x.png" width="48">

![image](/_media/Pasted%20image%2020251013221108.png)
Выше, $a_1,b_1$ - аргументы одного сумматора, $a_2,b_2$ - аргументы второго.

Композиция этих функция говорит, если этот участок из двух разрядов при сложении переопределяет $carry$ бит на что-то детерменированное, или пропускает то что шло до него.

Мы можем масштабировать эту систему, чтобы выяснить как ведёт себя вся совокупность из $n$ бит (разрядов), чтобы вычислить все биты переноса за глубину $log_2\;n$.

Ниже приводится схематика того, как это работает.

![image](/_media/Pasted%20image%2020251013223130.png)
>Недеюсь этот конспект используют достаточно человек чтобы оправдать время на рисование этой схемы...