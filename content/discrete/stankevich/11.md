---
title: "Алгоритм генерации, объект по номеру, номер по объекту, следующий объект"
index: 11
description: "Лекция 11"
lectureYouTubeLink:
  - "https://www.youtube.com/watch?v=HtcMflivGBM"
author:
  name: "Худалла А.Б."
  isu: 501855
---

mjx-hidden
$\newcommand{\ihat}{\hat \imath}$
$\newcommand{\jhat}{\hat \jmath}$
$\newcommand{\pipe}{\,|\,}$
$\newcommand{\lra}{\Leftrightarrow}$
$\newcommand{\la}{\Leftarrow}$
$\newcommand{\ra}{\Rightarrow}$
$\newcommand{\mb}{\mathbb}$
$\newcommand{\br}[1]{\{{#1}\}}$
$\newcommand{\ang}[1]{\left \langle{#1}\right\rangle}$
$\newcommand{\ov}{\overline}$
$\newcommand{\argsum}[2]{\underset{#2}{\overset {#1}\sum}}$
$\newcommand{\arghuge}[1]{\huge{#1}\;\normalsize}$
$\newcommand{\tmatrix}[1]{\begin{pmatrix}#1\end{pmatrix}}$
$\newcommand{\bmatrix}[1]{\begin{Bmatrix}#1\end{Bmatrix}}$
$\newcommand{\matal}[1]{\begin{align}#1\end{align}}$
$\newcommand{\pmatrix}[1]{\begin{vmatrix}#1\end{vmatrix}}$
$\newcommand{\system}[1]{\left \{ \begin{align}#1\end{align} \right .}$
$\newcommand{\mc}{\mathcal}$
$\newcommand{\argoplus}[2]{\large \overset{#1}{\underset{#2}\oplus}\normalsize}$
$\newcommand{\arglarge}[3]{\large \overset{#2}{\underset{#3}#1}\normalsize}$
$\newcommand{\mod}[1]{\left | #1 \right |}$

## Алгоритмы генерации и нумерации комбинаторных объектов


### Двоичные вектора фиксированной длины

$\mb B^n$

>Пример:
>$\mb B^3:$
>$000$
>$001$
>$010$
>$...$
>$111$

```python
gen:
	gen all, starting with 0
	gen all, starting with 1
```

Рекурсивный вызов:

![image](/_media/Pasted%20image%2020251123190552.png)

```python
gen(p):
	if len(p)=n:
		print p
		return
	gen(p+[0])
	gen(p+[1])

main:
	gen([])
```

---

### Перестановки

$n=3$
$123$
$\underline{132}$
$213$
$231$
$\ov{312}$
$321$

```python
gen(p):
	if len(p) = n
		print(p)
		return
	for i = 1..n:
		if i not in p:
			gen(p+[i])
			
main:
	gen([])
```

---

Все строки из $0$ и $1$ длины $\leq n: \arglarge \cup n {k=0} \mb B^k$
```python
gen(p):
	print(p)
	if len(p) = n:
		return
	gen(p + [0])
	gen(p + [1])
```

---
### Общая запись

$p$ - префикс комбинаторного объекта

$C \subset \Sigma^*$

```python
gen(p):
	if (p = комбинаторный объект):
		print(p)
	for (C in ∑): (перебор в возрастающем порядке):
		if (p + [C] - префикс комбинаторного объекта):
			gen(p+[C])
```

---

### Сочетания

$n$
$k$
$\Sigma = \br{1,2,...,n}$

```python
gen(p):
	if len(p) = k:
		print(p)
		return
	for (c = 1 .. n):
		if p ≠ [] and C ≤ p[-1]:
			continue
		if n - c < k - len(p) - 1:
			continue
		gen(p+[c])
```

 ---
### Правильные скобочные последовательности

$(())()$
Баланс $= \#(-\#) \geq 0$
В конце баланс равен $= 0$

$n=1$
$()$

$n=2$
$(())$
$()()$

$n=3$
$((()))$
$(()())$
$(())()$
$()(())$
$()()()$

$\Sigma = \br{(,)}$

```python
gen(p):
	if len(p) = 2n:
		print(p)
		return
	if bal + 1 ≤ 2n-len(p)-1;
		gen(p+["("], bal+1)
	if bal > 0:
		gen(p+[")"], bal-1)

main:
	gen([], 0)
```

---

### Оптимизируем (Перестановки)

```python
a = <...>
used = <...> - взятые элементы
gen(p): p - длина префикса
	if p == n:
		print(a)
		return
	for i = 1 .. n:
		if !used[i]
			used[i] = true
			a[p] = i
			gen(p+1)
			used[i] = false
```

---

### Нумеруем перестановки

$0: 123$
$1: 132$
$2: 213$
$3: 231$
$4: 312$
$5: 321$

```python
gen(p):
	if p == n:
		if k == 0:
			print(a)
		k--
		return
	for i = 1 .. n:
		if !used[i]:
			if k ≥ (n-p-1)!:
				k -= (n-p-1)!
			else:
				used[i] = true
				a[p] = i
				gen(p+1)
				return
```

---

### Нумеруем в общем случае

```python
gen(p):
	if (p = комбинаторный объект):
		print(p)
	for (C in ∑): (перебор в возрастающем порядке):
		if (p + [C] - префикс комбинаторного объекта):
			t = кол-во комбинаторных объектов с префиксом p+[c]
			if k ≥ t:
				k -= t
			else gen(p+[c]):
				return
```

Если $c$ фиксированно (например $n-p-1!$), то мы можем заранее посчитать сколько пропусков нужно сделать$: \lfloor k/(n-p-1)! \rfloor$
Тогда $c = \lfloor k/(n-p-1)! \rfloor + 1 \rightarrow$ берём $c-$й неиспользованный элемент
$\ra$ перестановка по номеру за $n\;log\;n$

---

### Сочетания по номеру

```python
gen(p):
	if p == m:
		print(a)
		return
	for p == 0 ? 0 : a[p-1] ... n - m + p + 1
		t = C(n-c, m-p-1)
		if k ≥ t:
			k -= t
		else:
			gen(p+1)
```

---

$z$ - к.о.

```python
gen(p):
	if p-комбианторный объект:
		if p == z:
			res = k
		else:
			k++
	for (c in ∑):
		if (p + [c] префикс ко):
			gen(p+[c])
```

---

### Общий универсальный алгоритм для следующего к.о. (Next permutation)

![image](/_media/CleanShot%202025-11-23%20at%2022.33.39@2x.png)

1) $p$ - максимальный префикс, который можно сохранить увеличив следующий
2) Следующий элемент нужно увеличить минимальным образом $a \rightarrow b$
3) $t$ - элементу $p+b$ нужно приписать минимальный "хвост"

>Пример (Двоичный вектор):
> $\underbracket{010110111}_p\matal{\\ \\&011 \\ &\overset \downarrow 1\overbracket{00}^t}$
>Пример (Перестановка):
>$\matal{\\ \underbracket 3_p \underbrace{576421} \\ 612467}$